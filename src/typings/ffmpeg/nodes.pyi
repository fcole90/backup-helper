"""
This type stub file was generated by pyright.
"""

from .dag import KwargReprNode

class Stream:
    """Represents the outgoing edge of an upstream node; may be used to create more downstream nodes."""
    def __init__(self, upstream_node, upstream_label, node_types, upstream_selector=...) -> None:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __getitem__(self, index):
        """
        Select a component (audio, video) of the stream.

        Example:
            Process the audio and video portions of a stream independently::

                input = ffmpeg.input('in.mp4')
                audio = input['a'].filter("aecho", 0.8, 0.9, 1000, 0.3)
                video = input['v'].hflip()
                out = ffmpeg.output(audio, video, 'out.mp4')
        """
        ...
    
    @property
    def audio(self):
        """Select the audio-portion of a stream.

        Some ffmpeg filters drop audio streams, and care must be taken
        to preserve the audio in the final output.  The ``.audio`` and
        ``.video`` operators can be used to reference the audio/video
        portions of a stream so that they can be processed separately
        and then re-combined later in the pipeline.  This dilemma is
        intrinsic to ffmpeg, and ffmpeg-python tries to stay out of the
        way while users may refer to the official ffmpeg documentation
        as to why certain filters drop audio.

        ``stream.audio`` is a shorthand for ``stream['a']``.

        Example:
            Process the audio and video portions of a stream independently::

                input = ffmpeg.input('in.mp4')
                audio = input.audio.filter("aecho", 0.8, 0.9, 1000, 0.3)
                video = input.video.hflip()
                out = ffmpeg.output(audio, video, 'out.mp4')
        """
        ...
    
    @property
    def video(self):
        """Select the video-portion of a stream.

        Some ffmpeg filters drop audio streams, and care must be taken
        to preserve the audio in the final output.  The ``.audio`` and
        ``.video`` operators can be used to reference the audio/video
        portions of a stream so that they can be processed separately
        and then re-combined later in the pipeline.  This dilemma is
        intrinsic to ffmpeg, and ffmpeg-python tries to stay out of the
        way while users may refer to the official ffmpeg documentation
        as to why certain filters drop audio.

        ``stream.video`` is a shorthand for ``stream['v']``.

        Example:
            Process the audio and video portions of a stream independently::

                input = ffmpeg.input('in.mp4')
                audio = input.audio.filter("aecho", 0.8, 0.9, 1000, 0.3)
                video = input.video.hflip()
                out = ffmpeg.output(audio, video, 'out.mp4')
        """
        ...
    


def get_stream_map(stream_spec): # -> dict[None, Stream] | dict[int, Any] | dict[Any, Any]:
    ...

def get_stream_map_nodes(stream_map): # -> list[Any]:
    ...

def get_stream_spec_nodes(stream_spec): # -> list[Any]:
    ...

class Node(KwargReprNode):
    """Node base"""
    def __init__(self, stream_spec, name, incoming_stream_types, outgoing_stream_type, min_inputs, max_inputs, args=..., kwargs=...) -> None:
        ...
    
    def stream(self, label=..., selector=...):
        """Create an outgoing stream originating from this node.

        More nodes may be attached onto the outgoing stream.
        """
        ...
    
    def __getitem__(self, item):
        """Create an outgoing stream originating from this node; syntactic sugar for ``self.stream(label)``.
        It can also be used to apply a selector: e.g. ``node[0:'a']`` returns a stream with label 0 and
        selector ``'a'``, which is the same as ``node.stream(label=0, selector='a')``.

        Example:
            Process the audio and video portions of a stream independently::

                input = ffmpeg.input('in.mp4')
                audio = input[:'a'].filter("aecho", 0.8, 0.9, 1000, 0.3)
                video = input[:'v'].hflip()
                out = ffmpeg.output(audio, video, 'out.mp4')
        """
        ...
    


class FilterableStream(Stream):
    def __init__(self, upstream_node, upstream_label, upstream_selector=...) -> None:
        ...
    


class InputNode(Node):
    """InputNode type"""
    def __init__(self, name, args=..., kwargs=...) -> None:
        ...
    
    @property
    def short_repr(self):
        ...
    


class FilterNode(Node):
    def __init__(self, stream_spec, name, max_inputs=..., args=..., kwargs=...) -> None:
        ...
    


class OutputNode(Node):
    def __init__(self, stream, name, args=..., kwargs=...) -> None:
        ...
    
    @property
    def short_repr(self):
        ...
    


class OutputStream(Stream):
    def __init__(self, upstream_node, upstream_label, upstream_selector=...) -> None:
        ...
    


class MergeOutputsNode(Node):
    def __init__(self, streams, name) -> None:
        ...
    


class GlobalNode(Node):
    def __init__(self, stream, name, args=..., kwargs=...) -> None:
        ...
    


def stream_operator(stream_classes=..., name=...): # -> Callable[..., Any]:
    ...

def filter_operator(name=...): # -> Callable[..., Any]:
    ...

def output_operator(name=...): # -> Callable[..., Any]:
    ...

__all__ = ['Stream']
